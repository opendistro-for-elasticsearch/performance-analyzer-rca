/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 */

package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jooq.DSLContext;
import org.jooq.Field;
import org.jooq.JSONFormat;
import org.jooq.Record;
import org.jooq.Result;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;

class SQLitePersistor extends PersistorBase {
  private static final String DB_URL = "jdbc:sqlite:";
  private DSLContext create;
  private Map<String, List<Field<String>>> jooqTableColumns;
  private static final Logger LOG = LogManager.getLogger(SQLitePersistor.class);

  SQLitePersistor(String dir, String filename) throws SQLException {
    super(dir, filename, DB_URL);
    create = DSL.using(conn, SQLDialect.SQLITE);
    jooqTableColumns = new HashMap<>();
  }

  // This updates the DSL context based on a new SQLite connection
  // It is needed during SQLite file rotation
  @Override
  synchronized void createNewDSLContext() {
    create = DSL.using(super.conn, SQLDialect.SQLITE);
    jooqTableColumns = new HashMap<>();
  }

  @Override
  synchronized void createTable(String tableName, List<String> columns) {
    List<Field<String>> fields =
        columns.stream()
            .map(s -> DSL.field(DSL.name(s), String.class))
            .collect(Collectors.toList());
    create.createTable(tableName).columns(fields).execute();
    jooqTableColumns.put(tableName, fields);
  }

  @Override
  synchronized void insertRow(String tableName, List<String> row) {
    LOG.debug("RCA: Table: {}, Row:\n{}", tableName, row);
    create
        .insertInto(DSL.table(tableName))
        .columns(jooqTableColumns.get(tableName))
        .values(row)
        .execute();
  }

  // This reads all SQLite tables in the latest SQLite file and converts the read data to JSON.
  @Override
  synchronized String readTables() {
    StringBuilder jsonResult = new StringBuilder();
    final JSONFormat jsonFormat = new JSONFormat().header(false);
    jsonResult.append("{");
    // Currently returning a json string response generated by jooq library formatJSON method
    // Need to change this because currently maps are being stored as strings in JSON instead of
    // objects
    String tableJson =
        super.tableNames.stream()
            .map(
                table -> {
                  StringBuilder jsonForEachTable = new StringBuilder();
                  jsonForEachTable.append("\"" + table + "\":");
                  Result<Record> result = create.select().from(table).fetch();
                  jsonForEachTable.append(result.formatJSON(jsonFormat));
                  return jsonForEachTable.toString();
                })
            .collect(Collectors.joining(","));
    jsonResult.append(tableJson);
    jsonResult.append("}");
    LOG.debug("JSON Result - " + jsonResult);
    return jsonResult.toString();
  }
}
